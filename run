#!/usr/bin/env python3

import sys
import os
import subprocess
import json
import re
import pathlib


def sort_key(json_obj):
    return -json_obj["NET_SCORE"]


def parse_test_results(test_dump: str):
    """
    Parse results of running jest on tests
    :param test_dump: stdout from running jest
    :return: test_cases_passed, total_test_cases, percentage_coverage
    """

    searches: list = [
        r"All files\s*\|[^\|]*\|[^\|]*\|[^\|]*\|\s*",
        r"\d*\.\d*",
        r"Tests:\s*(\s*\d\s*failed,\s*\d\s*skipped,\s*|\d\s*failed,\s*|\d\s*skipped,\s*)?",
        r"\d*",
        r"\d*\s*passed,\s*",
        r"\d*",
    ]

    results: list = []

    for i in range(0, len(searches), 2):
        search_result: re.Match = re.search(searches[i], test_dump)
        if not search_result:
            return -1, -1, -1
        _, end = search_result.span()
        test_dump = test_dump[end:]

        search_result: re.Match = re.search(searches[i + 1], test_dump)
        if not search_result:
            return -1, -1, -1
        _, end = search_result.span()
        results.append(test_dump[:end])

    coverage, passed, total = results

    return passed, total, coverage


def main():
    if len(sys.argv) < 2:
        print("Error: No mode specified.")
        return 1

    try:
        with open(os.getenv("LOG_FILE"), "w") as f:
            pass
    except:
        # No log file was provided or it couldn't be opened
        error_msg = "Warning: No log file provided.\n"
        error_msg += "To enable logging, set a path to a logging file in "
        error_msg += "environment variable LOG_FILE and set the log level "
        error_msg += "in environment variable LOG_LEVEL."
        print(error_msg)

    mode = sys.argv[1]
    if mode == "install":
        ## try:
        ##     node_ver = subprocess.run(
        ##         ["node --version"], stdout=subprocess.PIPE, shell=True
        ##     ).stdout.decode("utf-8")
        ## except:
        ##     # Node not installed
        ##     node_ver = 0
        ##
        ##
        ## commands = [
        ##     ['curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash'],
        ##     ['export NVM_DIR="$HOME/.nvm"'],
        ##     ['[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"'],
        ##      ['[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"'],
        ##  ]
        ##
        ## #If not 18.14.0, install nvm and use it to install 18.14.0
        ## if (node_ver != "v18.14.0"):
        ##     for command in commands:
        ##         process = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)
        ##         process.wait()
        ##
        ##     p = subprocess.Popen(['/usr/bin/bash', '-i', '-c', 'nvm install 18.14.0'])
        ##     p.wait()
        ##
        ##     p = subprocess.Popen(['/usr/bin/bash', '-i', '-c', 'nvm use 18.14.0'])
        ##     p.wait()
        ##
        ##     p = subprocess.Popen(['/usr/bin/bash', '-i', '-c', 'source ~/.bashrc'])
        ##     p.wait()

        # INSTALL DEPENDENCIES

        ## try:
        ##     os.system('export PATH=$(pwd)/node_bin/bin/:$PATH')
        ##     pass
        ## except:
        ##     print("Error: Could not export path")
        ##     pass

        ret_val = subprocess.run("npm install --loglevel=error", shell=True)
        if ret_val.returncode != 0:
            print("Error: NPM Install failed")
            return 1

        return 0

    elif mode == "build":
        # BUILD PROJECT
        ret_val = subprocess.run("tsc src/*.ts", shell=True)
        if ret_val.returncode != 0:
            print("Error: Build failed")
            return 1
        return 0

    elif mode == "test":
        # RUN TESTS
        command = "npm test logging.test.ts"
        result: subprocess.CompletedProcess = subprocess.run(
            command, shell=True, capture_output=True
        )
        passed, total, coverage = parse_test_results(
            result.stdout.decode("utf-8") + result.stderr.decode("utf-8")
        )
        if passed == total == coverage == -1:
            print("Testing data could not be acquired")
            return 1
        else:
            print(
                f"{passed}/{total} test cases passed. {coverage}% line coverage achieved."
            )
        return 0
    else:
        # RANK MODULES
        if len(sys.argv) < 2:
            print("Arg 1 needs to be URL to input file or one of")
            return 1

        if not os.getenv("GITHUB_TOKEN"):
            print(
                "Error: Please specify GitHub token in environment variable GITHUB_TOKEN"
            )
            return 1

        file_path = sys.argv[1]

        try:
            file = open(file_path, "r")
        except FileNotFoundError:
            print(f"Error: File not found at path: {file_path}")
            return 1

        with file:
            output_list = []
            for line in file:
                # create the command string
                line = line.strip()
                command = f"node_bin/bin/node src/main.js {line}"

                # call main with each URL as argument
                result = subprocess.run(command, shell=True, capture_output=True)
                try:
                    json_output = json.loads(result.stdout.decode().strip())
                    output_list.append(json_output)
                except:
                    print(f"Error when running command: {command}")
                    return 1

        output_list = sorted(output_list, key=sort_key)
        output_str = "\n".join([json.dumps(item) for item in output_list])
        print(output_str)
        # root_dir = pathlib.PurePath(__file__).parent
        # with open(root_dir.joinpath("output.ndjson"), "w") as f:
        #     f.write(output_str)


if __name__ == "__main__":
    main()
